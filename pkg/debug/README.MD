# DebugCollector — описание

DebugCollector — это лёгкий инфраструктурный компонент для **сбора отладочной информации в рамках одного запроса**.

Он предназначен для:
- диагностики,
- анализа производительности,
- понимания хода выполнения бизнес-логики.

DebugCollector **не является логгером**, **не влияет на выполнение кода** и используется исключительно как диагностический слой.

---

## Основные принципы

- Один collector = один запрос
- Хранится и передаётся через `context.Context`
- Не привязан к SQL / HTTP / Redis — полностью модульный
- Может использоваться из любого слоя приложения
- Безопасен: если collector отсутствует, код просто ничего не делает

---

## Пример добавления информации в Collector

```go
    if dbg := debug.GetDebugFromContext(context); dbg != nil {
        dbg.AddStep("asdfasdf")

		dbg.AddStatement("http", execTime, debug.HttpStatement{
            Method: "GET",
            URL:    "https://api.example.com",
            Status: 200,
        })
    }
```

---

## Что собирает DebugCollector

### Meta

Произвольные метаданные запроса.

Рекомендуется использовать для:
- request_id
- url
- method
- service
- env

Если `meta` пустая, она не попадает в JSON-ответ.

---

### Steps

Последовательность шагов выполнения бизнес-логики.

Используется для:
- понимания сценария выполнения,
- быстрой локализации проблем,
- диагностики сложных flow’ов.

Пример:
- handler:start
- validate:input
- call:external-api
- save:db

---

### Categories

Категории — это логические группы отладочных событий.

Примеры:
- http
- db
- cache
- external.payment
- search.elastic

Каждая категория агрегирует:
- количество событий
- суммарное время

---

### TotalTime

Общее время выполнения запроса.

Используется для анализа производительности и поиска медленных endpoint’ов.

---

## Использование через context.Context

DebugCollector всегда передаётся через `context.Context`.

Любой код, получивший `ctx`, может:
- добавить шаг выполнения,
- добавить событие в категорию,
- дополнить meta.

При отсутствии DebugCollector вызовы безопасны.

---

## Где создавать DebugCollector

Рекомендуемое место — HTTP middleware.

Middleware отвечает за:
- создание collector’а,
- помещение его в context,
- заполнение базовых meta,
- подсчёт общего времени запроса.

---

## Ограничения

Не рекомендуется:
- использовать внутри tight-loops;
- хранить большие payload’ы;
- сохранять токены, пароли и персональные данные;
- использовать как замену логированию или трассировке.

---

## Что DebugCollector НЕ делает

- не логирует;
- не отправляет данные во внешние системы;
- не влияет на бизнес-логику;
- не является distributed tracing.

---

## Итог

DebugCollector — это безопасный и расширяемый инструмент диагностики запросов,
позволяющий понимать, **что происходило во время выполнения запроса**,
не вмешиваясь в его выполнение.
